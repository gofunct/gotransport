// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package cloud

import (
	"context"
	"contrib.go.opencensus.io/exporter/stackdriver/monitoredresource"
	"database/sql"
	"github.com/aws/aws-sdk-go/aws/client"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/go-sql-driver/mysql"
	"go.opencensus.io/trace"
	"gocloud.dev/aws/rds"
	"gocloud.dev/blob"
	"gocloud.dev/blob/fileblob"
	"gocloud.dev/blob/gcsblob"
	"gocloud.dev/blob/s3blob"
	"gocloud.dev/gcp"
	"gocloud.dev/gcp/cloudsql"
	"gocloud.dev/mysql/cloudmysql"
	"gocloud.dev/mysql/rdsmysql"
	"gocloud.dev/requestlog"
	"gocloud.dev/runtimevar"
	"gocloud.dev/runtimevar/filevar"
	"gocloud.dev/runtimevar/paramstore"
	"gocloud.dev/runtimevar/runtimeconfigurator"
	"gocloud.dev/server"
	"gocloud.dev/server/sdserver"
	"gocloud.dev/server/xrayserver"
	"google.golang.org/genproto/googleapis/cloud/runtimeconfig/v1beta1"
	"net/http"
	"time"
)

// Injectors from aws.go:

func AWS(ctx context.Context, runvar string) (*Runtime, func(), error) {
	ncsaLogger := xrayserver.NewRequestLogger()
	client := _wireClientValue
	certFetcher := &rds.CertFetcher{
		Client: client,
	}
	api := InitializeApi()
	params := AwsSQLParams(api)
	db, cleanup, err := rdsmysql.Open(ctx, certFetcher, params)
	if err != nil {
		return nil, nil, err
	}
	v, cleanup2 := AppHealthChecks(db)
	options := _wireOptionsValue
	sessionSession, err := session.NewSessionWithOptions(options)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	xRay := xrayserver.NewXRayClient(sessionSession)
	exporter, cleanup3, err := xrayserver.NewExporter(xRay)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	sampler := trace.AlwaysSample()
	defaultDriver := _wireDefaultDriverValue
	serverOptions := &server.Options{
		RequestLogger:         ncsaLogger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
		Driver:                defaultDriver,
	}
	serverServer := server.New(serverOptions)
	bucket, err := AwsBucket(ctx, sessionSession, api)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	variable, err := AwsRunVar(ctx, sessionSession, api)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	runtime := NewRuntime(runvar, serverServer, db, bucket, variable)
	return runtime, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

var (
	_wireClientValue        = http.DefaultClient
	_wireOptionsValue       = session.Options{}
	_wireDefaultDriverValue = &server.DefaultDriver{}
)

// Injectors from gcp.go:

func GCP(ctx context.Context, runvar string) (*Runtime, func(), error) {
	stackdriverLogger := sdserver.NewRequestLogger()
	roundTripper := gcp.DefaultTransport()
	credentials, err := gcp.DefaultCredentials(ctx)
	if err != nil {
		return nil, nil, err
	}
	tokenSource := gcp.CredentialsTokenSource(credentials)
	httpClient, err := gcp.NewHTTPClient(roundTripper, tokenSource)
	if err != nil {
		return nil, nil, err
	}
	remoteCertSource := cloudsql.NewCertSource(httpClient)
	projectID, err := gcp.DefaultProjectID(credentials)
	if err != nil {
		return nil, nil, err
	}
	api := InitializeApi()
	params := GcpSqlParams(projectID, api)
	db, err := cloudmysql.Open(ctx, remoteCertSource, params)
	if err != nil {
		return nil, nil, err
	}
	v, cleanup := AppHealthChecks(db)
	monitoredresourceInterface := monitoredresource.Autodetect()
	exporter, cleanup2, err := sdserver.NewExporter(projectID, tokenSource, monitoredresourceInterface)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	sampler := trace.AlwaysSample()
	defaultDriver := _wireDefaultDriverValue
	options := &server.Options{
		RequestLogger:         stackdriverLogger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
		Driver:                defaultDriver,
	}
	serverServer := server.New(options)
	bucket, err := GcpBucket(ctx, api, httpClient)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	runtimeConfigManagerClient, cleanup3, err := runtimeconfigurator.Dial(ctx, tokenSource)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	variable, cleanup4, err := GcpRunVar(ctx, runtimeConfigManagerClient, projectID, api)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	runtime := NewRuntime(runvar, serverServer, db, bucket, variable)
	return runtime, func() {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// Injectors from local.go:

func LOCAL(ctx context.Context, runvar string) (*Runtime, func(), error) {
	logger := _wireLoggerValue
	api := InitializeApi()
	db, err := DialLocalSQL(api)
	if err != nil {
		return nil, nil, err
	}
	v, cleanup := AppHealthChecks(db)
	exporter := _wireExporterValue
	sampler := trace.AlwaysSample()
	defaultDriver := _wireDefaultDriverValue
	options := &server.Options{
		RequestLogger:         logger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
		Driver:                defaultDriver,
	}
	serverServer := server.New(options)
	bucket, err := LocalBucket(api)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	variable, cleanup2, err := LocalRuntimeVar(api)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	runtime := NewRuntime(runvar, serverServer, db, bucket, variable)
	return runtime, func() {
		cleanup2()
		cleanup()
	}, nil
}

var (
	_wireLoggerValue   = requestlog.Logger(nil)
	_wireExporterValue = trace.Exporter(nil)
)

// aws.go:

func AwsBucket(ctx context.Context, cp client.ConfigProvider, a API) (*blob.Bucket, error) {
	return s3blob.OpenBucket(ctx, cp, a.Bucket(), nil)
}

func AwsSQLParams(a API) *rdsmysql.Params {
	return &rdsmysql.Params{
		Endpoint: a.DbHost(),
		Database: a.DbName(),
		User:     a.DbUser(),
		Password: a.DbPassword(),
	}
}

func AwsRunVar(ctx context.Context, sess client.ConfigProvider, a API) (*runtimevar.Variable, error) {
	dur, err := time.ParseDuration(a.RunVarTimeout())
	if err != nil {
		dur = 15 * time.Second
	}
	return paramstore.NewVariable(sess, a.RunVarValue(), runtimevar.StringDecoder, &paramstore.Options{
		WaitDuration: dur,
	})
}

// gcp.go:

func GcpBucket(ctx context.Context, a API, client2 *gcp.HTTPClient) (*blob.Bucket, error) {
	return gcsblob.OpenBucket(ctx, client2, a.Bucket(), nil)
}

func GcpSqlParams(id gcp.ProjectID, a API) *cloudmysql.Params {
	return &cloudmysql.Params{
		ProjectID: string(id),
		Region:    a.DbRegion(),
		Instance:  a.DbHost(),
		Database:  a.DbName(),
		User:      a.DbUser(),
		Password:  a.DbPassword(),
	}
}

func GcpRunVar(ctx context.Context, client2 runtimeconfig.RuntimeConfigManagerClient, project gcp.ProjectID, a API) (*runtimevar.Variable, func(), error) {
	name := runtimeconfigurator.ResourceName{
		ProjectID: string(project),
		Config:    a.RunVarName(),
		Variable:  a.RunVarValue(),
	}
	dur, err := time.ParseDuration(a.RunVarTimeout())
	if err != nil {
		dur = 15 * time.Second
	}
	v, err := runtimeconfigurator.NewVariable(client2, name, runtimevar.StringDecoder, &runtimeconfigurator.Options{
		WaitDuration: dur,
	})
	if err != nil {
		return nil, nil, err
	}
	return v, func() { v.Close() }, nil
}

// local.go:

// localBucket is a Wire provider function that returns a directory-based bucket
// based on the command-line a.
func LocalBucket(a API) (*blob.Bucket, error) {
	return fileblob.OpenBucket(a.Bucket(), nil)
}

// dialLocalSQL is a Wire provider function that connects to a MySQL database
// (usually on localhost).
func DialLocalSQL(a API) (*sql.DB, error) {
	cfg := &mysql.Config{
		Net:                  "tcp",
		Addr:                 a.DbHost(),
		DBName:               a.DbName(),
		User:                 a.DbUser(),
		Passwd:               a.DbPassword(),
		AllowNativePasswords: true,
	}
	return sql.Open("mysql", cfg.FormatDSN())
}

func LocalRuntimeVar(a API) (*runtimevar.Variable, func(), error) {
	dur, err := time.ParseDuration(a.RunVarTimeout())
	if err != nil {
		dur = 15 * time.Second
	}
	v, err := filevar.New(a.RunVarValue(), runtimevar.StringDecoder, &filevar.Options{
		WaitDuration: dur,
	})
	if err != nil {
		return nil, nil, err
	}
	return v, func() { v.Close() }, nil
}
